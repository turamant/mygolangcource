                                    Введение

В какой-то момент времени вы хотите, чтобы ваше веб-приложение сохраняло и извлекало данные
из базы данных. Это почти всегда так, когда вы имеете дело с динамическим контентом,
обслуживая формы для ввода данных пользователями или сохраняя учетные данные для входа
и пароля, чтобы ваши пользователи могли их аутентифицировать.
Для этой цели у нас есть базы данных.
Базы данных бывают разных форм и видов. Одной из наиболее часто используемых баз данных
во всем Интернете является база данных MySQL. Она существует уже много лет и доказала
свою позицию и стабильность больше раз, чем вы можете сосчитать.
В этом примере мы рассмотрим основы доступа к базам данных в Go, создадим таблицы базы
данных, сохраним данные и извлечем их обратно.

                        Установка go-sql-driver/mysqlпакета
Язык программирования Go поставляется с удобным пакетом под названием `database/sql`
для запросов ко всем видам баз данных SQL. Это полезно, поскольку он абстрагирует все
общие функции SQL в единый API для вашего использования. Чего Go не включает,
так это драйверов баз данных. В Go драйвер базы данных — это пакет, который реализует
низкоуровневые детали конкретной базы данных (в нашем случае MySQL).
Как вы уже могли догадаться, это полезно для сохранения прямой совместимости.
Поскольку на момент создания всех пакетов Go авторы не могли предвидеть, что каждая
отдельная база данных появится в будущем, и поддержка каждой возможной базы данных
потребовала бы большого объема работы по обслуживанию.
Чтобы установить драйвер базы данных MySQL, перейдите в терминал по вашему выбору и
выполните:
go get -u github.com/go-sql-driver/mysql

                        Подключение к базе данных MySQL
Первое, что нам нужно проверить после установки всех необходимых пакетов, это то, можем
ли мы успешно подключиться к нашей базе данных MySQL. Если у вас еще нет работающего
сервера базы данных MySQL, вы можете легко запустить новый экземпляр с Docker.
Вот официальная документация для образа Docker MySQL:https://hub.docker.com/_/mysql

Чтобы проверить, можем ли мы подключиться к нашей базе данных, импортируйте пакет
database/sqlи go-sql-driver/mysqlоткройте соединение следующим образом:
import "database/sql"
import _ "go-sql-driver/mysql"


// Настройте подключение к базе данных (всегда проверяйте ошибки)
db, err := sql.Open("mysql", "username:password@(127.0.0.1:3306)/dbname?parseTime=true")


// Инициализируем первое подключение к базе данных, чтобы проверить, все ли работает правильно.
// Обязательно проверьте ошибку.
err := db.Ping()

                        Создание нашей первой таблицы базы данных
Каждая запись данных в нашей базе данных хранится в определенной таблице.
Таблица базы данных состоит из столбцов и строк. Столбцы дают каждой записи данных
метку и указывают ее тип. Строки — это вставленные значения данных.
В нашем первом примере мы хотим создать таблицу следующего вида:

идентификатор	имя пользователя	пароль	создан в
1	               Джон Доу	        секрет	2019-08-10 12:30:00

В переводе на SQL команда создания таблицы будет выглядеть так:

CREATE TABLE users (
    id INT AUTO_INCREMENT,
    username TEXT NOT NULL,
    password TEXT NOT NULL,
    created_at DATETIME,
    PRIMARY KEY (id)
);
Теперь, когда у нас есть команда SQL, мы можем использовать пакет database/sqlдля создания таблицы в нашей базе данных MySQL:

query := `
    CREATE TABLE users (
        id INT AUTO_INCREMENT,
        username TEXT NOT NULL,
        password TEXT NOT NULL,
        created_at DATETIME,
        PRIMARY KEY (id)
    );`

// Выполняет SQL-запрос в нашей базе данных. 
// Проверьте err, чтобы убедиться в отсутствии ошибки.
_, err := db.Exec(query)

                        Вставляем нашего первого пользователя
Если вы знакомы с SQL, вставка новых данных в нашу таблицу так же проста, как и
создание нашей таблицы. Обратите внимание на следующее: по умолчанию Go использует
подготовленные операторы для вставки динамических данных в наши SQL-запросы, что
является способом безопасной передачи предоставленных пользователем данных в нашу базу
данных без риска какого-либо ущерба. На заре веб-программирования программисты
передавали данные непосредственно с запросом в базу данных, что вызывало огромные
уязвимости и могло сломать все веб-приложение. Пожалуйста, не делайте так.
Это легко сделать правильно.

Чтобы вставить нашего первого пользователя в таблицу базы данных, мы создаем SQL-запрос,
подобный следующему. Как вы видите, мы опускаем столбец id, так как он автоматически
устанавливается MySQL. Вопросительный знак сообщает драйверу SQL, что они являются
заполнителями для фактических данных. Здесь вы можете увидеть подготовленные операторы,
о которых мы говорили.

INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)

Теперь мы можем использовать этот SQL-запрос в Go и вставить новую строку в нашу
таблицу:

import "time"

username := "johndoe"
password := "secret"
createdAt := time.Now()

// Вставляет наши данные в таблицу пользователей и возвращает результат и возможную ошибку.
// Результат содержит информацию о последнем вставленном идентификаторе (который был
// сгенерирован автоматически) и количестве строк, на которые повлиял этот запрос.

result, err := db.Exec(`INSERT INTO users (username, password, created_at) VALUES (?, ?, ?)`, username, password, createdAt)

Чтобы получить только что созданный идентификатор для вашего пользователя, просто
сделайте это следующим образом:

userID, err := result.LastInsertId()

                    Запрос к нашей таблице пользователей
Теперь, когда у нас есть пользователь в нашей таблице, мы хотим запросить его и получить
обратно всю его информацию. В Go у нас есть две возможности для запроса наших таблиц.
Есть , db.Query которая может запросить несколько строк, чтобы мы могли перебрать их,
и есть , db.QueryRow если мы хотим запросить только определенную строку.

Запрос определенной строки работает в основном как любая другая команда SQL, которую мы
рассмотрели ранее.
Наша команда SQL для запроса одного пользователя по его идентификатору выглядит
следующим образом:
SELECT id, username, password, created_at FROM users WHERE id = ?

В Go мы сначала объявляем некоторые переменные для хранения наших данных, а затем
запрашиваем одну строку базы данных следующим образом:

var (
    id        int
    username  string
    password  string
    createdAt time.Time
)

// Опрашиваем базу данных и сканируем значения в выходные переменные. Не забудьте
// проверить наличие ошибок.

query := `SELECT id, username, password, created_at FROM users WHERE id = ?`
err := db.QueryRow(query, 1).Scan(&id, &username, &password, &createdAt)

                        Опрос всех пользователей
В предыдущем разделе мы рассмотрели, как запросить одну строку пользователя. Во многих
приложениях есть случаи использования, когда вы хотите запросить всех существующих
пользователей. Это работает аналогично примеру выше, но с немного большим количеством
кода.

Мы можем использовать команду SQL из примера выше и обрезать предложение WHERE.
Таким образом, мы запросим всех существующих пользователей.

SELECT id, username, password, created_at FROM users

В Go мы сначала объявляем некоторые переменные для хранения наших данных, а затем
запрашиваем одну строку базы данных следующим образом:

type user struct {
    id        int
    username  string
    password  string
    createdAt time.Time
}

rows, err := db.Query(`SELECT id, username, password, created_at FROM users`)
defer rows.Close()

var users []user
for rows.Next() {
    var u user
    err := rows.Scan(&u.id, &u.username, &u.password, &u.createdAt)
    users = append(users, u)
}
err := rows.Err()

Теперь срез пользователя может содержать что-то вроде этого:

users {
    user {
        id:        1,
        username:  "johndoe",
        password:  "secret",
        createdAt: time.Time{wall: 0x0, ext: 63701044325, loc: (*time.Location)(nil)},
    },
    user {
        id:        2,
        username:  "alice",
        password:  "bob",
        createdAt: time.Time{wall: 0x0, ext: 63701044622, loc: (*time.Location)(nil)},
    },
}

                    Удаление пользователя из нашей таблицы
Наконец, удаление пользователя из нашей таблицы так же просто, как и Exec в разделах
выше:

_, err := db.Exec(`DELETE FROM users WHERE id = ?`, 1)